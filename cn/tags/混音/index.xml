<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>混音 on RCJacH</title><link>https://RCJacH.github.io/cn/tags/%E6%B7%B7%E9%9F%B3/</link><description>Recent content in 混音 on RCJacH</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 08 Jan 2022 16:29:02 +0800</lastBuildDate><atom:link href="https://RCJacH.github.io/cn/tags/%E6%B7%B7%E9%9F%B3/index.xml" rel="self" type="application/rss+xml"/><item><title>RCInflator：破解百万级音频效果器算法，打破资本主义技术壁垒（大雾</title><link>https://RCJacH.github.io/cn/blog/rcinflator/</link><pubDate>Sat, 08 Jan 2022 16:29:02 +0800</pubDate><guid>https://RCJacH.github.io/cn/blog/rcinflator/</guid><description>欢迎来到我们插件发布会的直播间， 我是本次直播的主持人， 也是本司的CEO，CTO，COO，CFO&amp;hellip;（以下省略100个职称） RCJacH。 在开始之前有我邀请大家阅读以下三个注意事项：
请不要询问为什么我们选择以文字形式直播。 大家都是音乐人， 都有非常高端的脑放。 调制旁通的插件都能听出变化， 文字转语音会有什么困难吗。
文中有一些【鼓掌】的标签， 是为了触发脑放中的鼓掌采样， 这样能显得有很多人关注这种冷门话题。
今天狗头不够用， 请大家自行脑补。
好了， 今天我们将要发布一款革命性的音频插件， 不过在此之间我先给大家科普一下行业现状。
音频插件行业一直被国外的资本主义统治。 而这些“恶毒的”资本家为了“剥削”我们这些用爱发电的音乐人， 用尽花言巧语引诱我们消费、 “骗取”我们的财产。 由于音频插件是个黑盒， 具体算法除了作者谁也说不清， 好不好使全靠“吹”， 这导致一些“聪明的”资本家发现只要找外包做个生锈破皮的硬件3D建模、 写个不知所云的宣传文案， 文中使用一些平时不会出现在同一个句子的抽象词， 例如“warmth（温暖）”、“glue（粘合）”、“life（生命）”、“power（力量）”、“tube（电子管）”等， 再贴上几张硬件设备的照片让买家产生联想， 就可以平躺收税了。
更可恶的是， 部分资本家并不满足于此， 而是会想尽办法榨干用户的剩余价值。 修几个Bug收一次钱， 整理一下代码库收一次钱， 重画个GUI又来收一次钱。 作为现实主义的加班人， 我们要全力抵制这种行为， 时刻提醒自己不可被华丽的外表蒙蔽双眼， 妥善对待口袋里的一块二毛三分钱。
有句古话说得好， 自己动手成单身狗丰衣足食。 经过十分钟长时间的艰苦奋斗， 我终于自主研发出了一款新的音频插件。
【鼓掌】
这款插件名叫RCInflator。 RC就是我， 因为是我做出来的， 所以肯定要写上我的名字， 不然写谷歌么？ Inflator则是插件的名字， 来源于inflate一词， 意思是通货膨胀。
非常符合当前的全球经济发展动向。
【鼓掌】
我在这里说明一下， Inflator这个词可能会使有些人联想到十几年前的一款同名插件, 但实际上这两者是完全不同的插件。
首先这两款的功能不一样。 我们来看一下那款同名插件的宣传文：
A unique and powerful plugin to increase loudness, without sacrificing sonic quality or dynamic range.</description></item><item><title>Airwindows Console插件系列概念及使用简介</title><link>https://RCJacH.github.io/cn/blog/aw-console-basics/</link><pubDate>Tue, 06 Jul 2021 20:12:58 +0800</pubDate><guid>https://RCJacH.github.io/cn/blog/aw-console-basics/</guid><description>我在上一篇文章中对比了一下Airwindows的Console插件， 今天我要讲讲怎样使用它们。
在此之前，请允许我先唠叨一下该系列插件的原理。
Airwindows Console插件的原理 Airwindows Console系列插件追求的是模拟(emulate)模拟(analog)调音台的相加效果。
相加效果，summing，指的是把多个信号合并在一起的过程。 对于数字信号而言，summing就是简单的加法。 举个例子， 数值为1的采样A与数值为2的采样B相加之后， 总和为3。
数学是不是很奇妙？
模拟调音台就不一样了。 它们是电力驱动的。 每个电子元件都需要用电来描绘信号、传递信号。 非常美好。 不过会出现以下这个现象。 当多个信号出现相位抵消的时候， 由于每个通道依然需要使用能量 (虽然相位抵消把这个能量“浪费”掉了)， 导致相关的电子元件变得更不稳定、更易失真， 会让信号受到一些不可描述的影响。
Console插件模仿的正是这个现象。
那它们是怎么实现的呢？
稍微有些复杂， 因为每个版本和变异所用的算法都稍微有些不同。 幸运的是， Airwindows的作者Chris写了一个剥离了染色功能只保留了核心概念的简化版。
PurestConsole。 也正是我上篇提到的日常款。
其算法很简单。 每个音轨过一个正弦函数sin(x)添加正失真， 经过DAW自带的（数字）summing功能合并之后， 再过一个反正弦函数arcsin(x)来逆转之前的失真。 Chris称之为反失真。
如果你觉得&amp;quot;Talk is cheap, show me the code&amp;quot;：
asin(sin(A) + sin(B)...) 如果你对视觉更敏感的话， 点击这里查看我在Desmos上做的图。
图中：
X轴为时域 Y轴为振幅 黑线为原信号 红线为Console渲染后的输出 蓝线为其中的差值－干湿之间的区别 目不转睛看一会儿（手动调一调参数）能注意到以下两点：
信号增强比例和输入音量成正比。 当输入总和高于0dB (y &amp;gt; 1)时， 输出值则属于未定义域。 实际使用时估计会有难听的失真， 所以do your gain-staging。 概念简要解释结束， 接下来让我们聊聊实际制作中的设置和应用吧</description></item><item><title>如何挑选Airwindows Console插件系列</title><link>https://RCJacH.github.io/cn/blog/aw-console-comparison/</link><pubDate>Thu, 01 Jul 2021 16:48:52 +0800</pubDate><guid>https://RCJacH.github.io/cn/blog/aw-console-comparison/</guid><description>Airwindows的仿调音台Summing功能的Console插件系列是好东西， 一些人甚至觉得比某款知名的A级模拟调音台还要好听。 自从开发者Chris Johnson把他家插件免费化了之后， 我每个工程都会大量使用。
最近我终于想明白了如何在REAPER内搭建Console系统 （之后有空再翻译）， 所以在想办法把Console插件直接嵌入到各种模板里。
不过他家插件有个小小的问题……选择太多了。
目前为止， 他已经出了两百多个免费插件了， 光Console相关的插件就已经有12个。 而且他每周都在开发新算法， 我作为用户反而有点跟不上他的开发速度。
对于收藏家来说， 能收集那么多奇特的染色插件来丰富我们的调色板是件非常幸福的事情。 更何况其中很多插件就像扭蛋一样， 使用之前根本不知道是干什么用的， 每次都有种拆礼物的感觉。 但是对于音频工作者来说， 这点反而是个灾难。 因为在制作过程中我们不希望被选择恐惧症打断思路， 也没有多少时间尝鲜。 实际上， 有效的工作流程应该是有一个常用插件外加两三个功能明确的代替品。 为了实现流畅的操作我们必须得使用空闲时间对这些资源进行整理， 挑出适合的， 舍弃用不上的。 为此，我创建了一个专门对比所有Airwindows Console插件的REAPER工程， 来看看每种Console到底染了什么色， 有什么区别， 哪个是最优选。
俗话说是驴是马拉出来遛遛。
工程放到REAPER官网上了，点击这里进入下载页面。
使用方式：
播放工程。 把单个静音的轨道Solo来听正弦波过Console Channel + Bus的声音。 静音的轨道名是所用的Console插件名称。 有一个没有挂插件的None轨道， 可以当成参考用的干信号， 也可以用来反向抵消其他轨来听失真染色的声音。 总线挂了几个自带的测量插件， 应该能对理解每个染色具体什么样能有些帮助， 尤其是频谱。 三个Source音轨挂了都挂上了自带的ReaSynths音源， 其中source 1在播放440Hz， source 2为880Hz（第一个泛音）， source 3则是用来测试非泛音的频率。 经过对比，我观察到了以下几点：
大部分插件哪怕仅有单轨输入也会产生失真， 除了Atmosphere, Console5RAW, Console6以及那两个PurestConsole。 多轨Summing肯定会有失真。毕竟染色就是失真，不给染色我们用这个插件干嘛。 所有失真都会产生直流偏差（0Hz信号）， 所以在ConsoleBus之后需要添加一个直流滤波器。 此方面自带的ReaEQ是所有插件中CPU用量最少的， 用它加一个20Hz的高通可以过滤大部分的偏差。 如果你想把其全部切除， Airwindows的Infrasonic插件能完美实现， 代价是更高的CPU用量。 染色是非线性的。 更高的输入音量会使过载算法产生更多泛音， 并且整个信号会在接近0dB的地方被削波， 所以别忘了Gain-Staging。 仅用正弦波的话，最难听的失真来自于Console4、Console6、及uLaw。 根据我个人的判断，最好听的几款如下： Atmosphere。据说是为了模拟声音在空气中融合的听感。 其失真较平均，没有突兀的听感。 Console5。更饱满，全频段失真上至奈奎斯特； Console5Dark， 此变异与原版反向后差别在-80dB左右， 而且主要是原频率以及前几个泛音， 但用Span把两个信号叠起来又看不出来什么区别。 此款CPU用量更少； Console5Raw，一个更干净的版本， 不过据说会出现一些不稳定的直流偏差。 Console7。听起来更空洞，基音音量会稍微小一点。 它还有个失真稍微更大一点的兄弟叫Console7Cascade。 PDConsole，PD代表Purest Drive。此款听起来失真量最小。 PurestConsole初版。 经不严谨测试它能跟PurestConsole2完全抵消， 但这款的CPU用量是所有Console里面最少的，都不到二代的一半。 而且！！这款跟Atmosphere也能完全抵消！！ 总结一下， 日常用PurestConsole， Console7当成超级模拟染色的Summing盒（它CPU用量最高）， PDConsole来当软胶（胶指粘合多个轨道的功能）， Console5或者Console5Dark当纽约式指脸怼人的硬胶。</description></item><item><title>REAPER信号流</title><link>https://RCJacH.github.io/cn/blog/signal-flow/</link><pubDate>Fri, 23 Jun 2017 00:00:00 +0000</pubDate><guid>https://RCJacH.github.io/cn/blog/signal-flow/</guid><description>什么是信号流？
在数字音频制作领域，信号流指的是信号（例如音频或MIDI）是如何经过DAW中每一层运算的。
因为我们在实际使用中常常会需要建立路由，无论是简单的信号发送、搭建模块合成器、还是建立使用Parameter Modulation的多轨模板，清晰地了解信号在DAW中的路径以及运算顺序会有非常大的帮助。
所以我画了以下这张图。
排除模拟输入(Input)以及输出(Output)，Reaper总共有四个信号处理阶段：Take（层），Item（块），Track（轨），Master**（总线）**。每一个阶段在音频运算方面是完全一样的（单纯的加法），唯一的区别只是使用方式以而已。
以下则是一张包含包络的细节图。
注释：
Take Trim = 层音量衰减（主页面块儿上&amp;quot;边&amp;quot;往下拽的衰减）。
另外几点
我们知道REAPER只有一种万能轨道。
信号发送到另一轨的思路与块的信号输入至所包含轨性质是一样的。
母轨道(Folder Track)就像微型总线一样，把所有子轨道的信号加在一块儿再处理。
音频/MIDI通道是同路由上平行的信号流。
音频只会相加同通道的信号。
音量推子、Trim包络、音量包络三者可以同时使用，也就是说可以同时有三层音量调整的方法（平衡、段落、微调之类的）。
监听FX（Monitor FX）在音频渲染时是旁通的。</description></item><item><title>Reaper字符串快捷键系统：Vimper Solo</title><link>https://RCJacH.github.io/cn/blog/vimper-solo/</link><pubDate>Sun, 05 Feb 2017 00:00:00 +0000</pubDate><guid>https://RCJacH.github.io/cn/blog/vimper-solo/</guid><description>当我们开始挖掘REAPER内隐藏着的几千个操作（Action），并且随着ReaPack的成长不断添加新的用户自制脚本与扩展时，我们会发现当我们需要自定义快捷键时，能用到的键位越来越少。而为了充分利用现有的字母、数字、以及符号键，我们通常需要加上各种如Ctrl，Alt甚至Win的修饰键进行各种高难度的键位组合，而且经常过几天可能就会忘掉一大半。
为了避免这种尴尬，我做了一个按组归类快捷键的脚本。它是依照VIM文本编辑器快捷键的理念，通过一串字符触发快捷键的。
点击这里下载Vimper Solo。
通过这个脚本，我们不需要去记各种修饰键，只需按组激发对应的键位就好了。例如，在这个脚本内，同一个m键可以根据不同的分组静音轨道、块或层，但在REAPER里，我们得去想到三个不同的修饰键组合来触发这三个不同的功能。有的时候由于记不住某个操作是要按Shift还是要按Ctrl还是Ctrl+Shift需要反复去试，浪费很多时间。
使用方法： 解压后把整个文件夹放到资源目录的Script文件夹内，然后在Reaper的Action List中加载RCJacH_Vimper Solo并为其设置一个快捷键（我用的是分号;）。
触发脚本，根据GUI窗口提示进入不同的分组并触发不同的操作。
使用Backspace退格键返回上一层菜单。
也可以在Action List中加载RCJacH_Vimper Solo Repeat Action来反复触发上一次触发操作。
在Bindings.lua文件里，可以依照现有项设置新的快捷键或者修改现有的快捷键。
格式：
分组= {
NAME = “分组”,
快捷键= {CommandID, 所显示的名称},
}
*注意，任何分组必须得包含NAME= “名称”一项，否则识别不到。
**分组可以有无数层。
***如果添加新的总分组，得在最底下的return{}里添加。
****快捷键目前区分大小写。
*****显示名称可以使用中文。</description></item><item><title>Reaper JSFX: NoiseBuzz噪音生成器</title><link>https://RCJacH.github.io/cn/blog/noisebuzz/</link><pubDate>Mon, 23 Jan 2017 00:00:00 +0000</pubDate><guid>https://RCJacH.github.io/cn/blog/noisebuzz/</guid><description>我们在混音或者声音设计的时候，经常需要在现有的军鼓上面叠一层噪音，这样能让军鼓听起来更满一点。为此，我们可能需要插入一个噪音生成器、一个门限再加上各种滤波器。我觉得调制起来很麻烦所以就把这三个放在了一起，做成了JS插件。这个插件会在输入音频信号超过Threshold阈值后触发动态噪音信号（噪音音量与输入音量有直接关系），并可以通过选项来调制这个噪音的动态包络以及频段限制。
这个插件可以用于军鼓轨道（通常是军鼓bottom mic），或者放在Overhead、Room、甚至混响轨来添加一些房间的沙沙声。甚至可以叠在HiHat轨以及Supersaw合成器轨。随意玩。
v1.3 (2018-03-08) Brown Noise Type. MIDI Trigger. Fixed sustain. Renamed to RCNoiseBuzz since the update broke backward compatibility. v1.2 (2017-04-08) Width Control. v1.1 (2017-03-11) Decay &amp;amp; Sustain Control. v1.0a (2017-01-31) Renamed to NoiseBuzz. v1.0 (2017-01-22) Initial Release. 下载地址： RCNoiseBuzz官网下载地址
RCJacH的ReaPack Repository包含REAPER Daw使用的Lua和JS脚本与效果器</description></item><item><title>REAPER JSFX - AB Comparison 8路信号对比脚本</title><link>https://RCJacH.github.io/cn/blog/ab-comparison/</link><pubDate>Fri, 20 Jan 2017 00:00:00 +0000</pubDate><guid>https://RCJacH.github.io/cn/blog/ab-comparison/</guid><description>昨天做了个JSFX小脚本：AB Comparison。目的是更方便的监听和对比不同信号（比如说不同插件、不同轨道）。
这个脚本可以根据所设置的节拍或者微秒长度，自动切换到不同的双声道通道。同时还包含一个盲听模式。
使用方法： 在任意音轨上放置 AB Comparison 这个JS脚本。
将所需对比的乐器、插件、音轨设置成不同的双声道输出，例：插件1 = 1-2，插件2 = 3-4，插件3 = 5-6&amp;hellip;一共能接收8个双声道输入。
将 # of Input 设置成需要对比的双声道个数。
将 Switch Beat length 设置为自动切换通道的拍数（每n拍切换一次）。或者，使用 Millisecond Mode 并将其设置为自动切换的毫秒数。
选择切换模式：
Manual = 手动模式，点击0-9任意触发按钮（或对应小键盘数字）切换到对应双声道通道。
Sequential = 循序模式，输出通道将按照所设置的间隔自动切换到下一个双声道。
Random = 随机模式，输出通道将按照所设置的间隔自动切换到一个不同的随机双声道。
Guessing = 盲听模式，随机切换到一个双声道，并隐藏显示正播放的通道。点击0-9任意触发按钮显示正在播放的通道。
使用 Answer Displaying Time 来调制盲听模式中，显示答案至 返回到 “Guess”的时间。</description></item><item><title>模拟信号与电子信号的音量关系：-20 dBFS = 0 VU</title><link>https://RCJacH.github.io/cn/blog/between-analog-and-digital-volume/</link><pubDate>Fri, 01 Apr 2016 00:00:00 +0000</pubDate><guid>https://RCJacH.github.io/cn/blog/between-analog-and-digital-volume/</guid><description>这篇文章会用最短的方式解释一下模拟信号与电子信号的音量关系。
图中有以下几点需要注意：
电子信号会在0 dBFS的状态下遭遇电子削波，而模拟信号会在+24 dBu（也就是+20VU）的状态下遭遇削波。
模拟设备在0VU以上会有逐渐增强的过载失真。
因为大部分模拟设备不会显示20dB的动态余量，而电子设备会，所以我们在用DAW的时候需要自行留出20dB的动态余量。也就是说让每一轨、每一个插件的输出音量平均值保持在-20dBFS左右（之后细讲），这样能保证我们用电子调音台时能与模拟调音台预留同样的动态余量。
在此基础上，我们可以使用各种防模拟失真的插件来模仿模拟设备的声音，例如AirWindows的Console4、ToneBooster的Ferox/Reelbus、Klanghelm的IVGI等等。</description></item><item><title>ReaComp到底有多强大？Pro Tools用户哭了。</title><link>https://RCJacH.github.io/cn/blog/reacomp-the-great/</link><pubDate>Thu, 10 Mar 2016 00:00:00 +0000</pubDate><guid>https://RCJacH.github.io/cn/blog/reacomp-the-great/</guid><description>在音频处理方面，压缩一词经常被捧上天。尤其是对听感的音量变化还不是很敏感的那些初学者们，会觉得压缩处理好像是一个非常神秘的步骤。其实压缩器的性质与手动调音量一样- 衰减音量大的部分并提升音量小的部分 – 只不过压缩比手动画音量能在更短的时间内做出反应与相对措施。那么他对音频具体有什么影响呢？我们来通过Reaper自带的ReaComp来观察一下。
ReaComp的界面的确不是最华丽的，但麻雀虽小五脏俱全：
音频信号压缩的原理是把输入信号分成两份，一份通过压缩本身的信号处理，而另一份则被用于检测衡量信号。这两份信号都可以在ReaComp内进行一定程度的处理来达到所需的效果。我们用图来解释一下ReaComp内的参数分别是什么。
假设我们输入的音频是这个样子，中间有一段音量突出的片段。
如果我们想用压缩来控制这个片段的话，我们需要调四个参数。最重要的两个是ReaComp左侧的阈值 (Threshold)以及正中央的压缩比例 (Ratio)。当输入音频音量高于阈值时，会按着所设置的Ratio对高出的范围进行衰减 (GR = Gain Reduction)。例，当输入音量比阈值高出4dB而Ratio为4:1时，超出阈值的片段会衰减至所超出范围的四分之一，输出音量则会比阈值高出1dB。
剩下的Attack和Release两个参数是用来控制衰减行为的时间b。Attack参数决定了音频从高于阈值那一刻起到最高衰减所需要的时间，而Release决定了在音频低于阈值后衰减恢复到0dB的时间。我们看一下这张图可能会更容易理解，图中的压缩比例为无限:1，也就是说GR会把超出音量降至阈值。
Class Attack选项会改变Attack的曲线，让音头衰减更慢一点，如图:
Auto Release选项是根据GR程度来计算是否需要延长Release的时间。假设我们在压缩军鼓时选择了Auto Release。如果GR是3dB，那么ReaComp会采取Release设置的x微秒；如果GR达到了20dB，Auto Release选项会让Release时间超出x，让Release时间变长。可惜的是，这样的设置在听觉上不是很舒服。许多模拟压缩所采取的Auto Release是根据GR时间长度来决定Release时间，也就是说在军鼓上衰减5dB与在贝斯上衰减5dB所造成的Release时长是不一样的。期待ReaComp能在未来的哪天实现这个功能。
在Ratio下方有一个Knee Size参数，他决定了GR与Threshold的关系。什么意思呢？想象一下，我们录过的主人声。有一些句子唱的很轻，一些句子音量稍微高一点，而副歌的时候音量会非常大。这个时候使用同一个阈值与压缩比例显然不是很合适。为什么呢？因为如果我们把阈值设置成仅仅低于副歌部分，那么前面的句子就不会被影响；而如果我们需要压缩所有信号，可能Ratio不会让副歌的音量衰减到平均范围，或者会让主歌部分压缩太多。这个时候，我们可以通过Knee Size来让GR变得更圆滑，让信号在Threshold前后Knee/2的范围内都有着不同比例的压缩。如图。
无压缩
Hard Knee
Soft Knee
Knee Size 之下的Detector input决定了检测信号的识别方式。可选项为双声道、单声道左/右、侧链双声道以及单声道（通过Channel 3 - 4的信号来激发对Channel 1 - 2的压缩）、以及Feedback (通过输出信号来激发压缩，让压缩稍微更圆润一点)。我们可以根据压缩的不同目的来选择不同识别方式，具体会在今后的文章中介绍。
再往下的两个参数分别是低通（Low Pass）与高通 (High Pass)，这个是用来调节检测信号的频段。假设我们的输入音频是一个低频比较重的木吉他，而他的低频与高频动态不是很平均的话，当低频超过了阈值，它就会触发我们不想要的衰减。这个时候如果我们把High Pass调到高于这个低频的频段，就可以让压缩只根据高频的动态来对整个信号进行适应的衰减。另一种用法是把两个参数调成齿音的频段，可以当成一个De-Esser用了。
好吧，我承认以上的参数一般压缩插件也都有（虽然调制范围有不同），并不会让ReaComp显得多么独特。但不用怕，接下来的两个参数正是ReaComp的杀手锏，那就是RMS Size和Pre-Comp。
RMS是什么？RMS，Root Mean-Square，简单来说就是一段时间的平均值。当RMS为0的时候，检测的动态为瞬间峰值的音量，也就是很多其他压缩插件的Peak Mode。如果我们把RMS调成10ms，算法会以10ms为单位检测这段时间的平均值来判断是否需要压缩，这样我们能让衰减更圆滑一点。ReaComp的RMS最高可以调到1000ms，也就是一秒。如果能调到5分钟的话差不多能直接自动做母带压缩了呵呵。
Pre-Comp算法相对更复杂一点，但我们目前可以把他看成信号检测预留时间。例如，当我们有一个特别短的音头需要压缩掉的时候，把Attack调成0（这是模拟压缩做不到的一点）则会造成一定程度的失真（因为音频采样需要从某个点瞬间移动到另一个点）。针对这个现象，我们可以调Pre-Comp，让插件在处理音头之前就已经开始进行衰减了，这样当我们处理到音头的时候就不会造成突然地失真。效果如下图：
注意，因为使用Pre-Comp需要让插件提前识别之后的音频，会增加宿主的延迟，所以可能这个工具更适合后期混音而非现场演奏、录音。
好了，我们把ReaComp中大部分参数意义复习了一遍，也该讲一讲它的神奇之处了。这个技巧最先由Cockos论坛会员ashcat_lt提出，准备好颠覆我们对压缩的概念吧。
我们知道RMS是截取一个段落的平均值，我们又知道Pre-Comp能让插件“预知”一段时间的音量。那么如果我们把Pre-Comp设置成RMS的一半左右，我们处理的则是一个峰值与它前后一段时间的平均值。这样等于音量会自然地在峰值之前衰减，而在峰值之后恢复。同时，因为Attack和Release已经包含在整个程序内了，我们不需要额外地添加Attack和Release。峰值的音头形状可能稍微取决于RMS与Pre-Comp * 2之差。利用这个方法，我们可以把Knee Size和Threshold调到比平常高一点的位置，让输入音频一直保持Knee中间的状态，GR大概保持在1.5dB以下就好了。这个压缩技术的效果就是在保留音头的情况下非常自然地降低了动态范围，甚至根本听不出来压缩的痕迹!
操作起来很简单，你只需要如下图这样设置，然后根据你的输入及目的来调制红色框内的Threshold、Ratio、与Knee Size(其实都可以不动)。
我还做了一个ReaComp预设，并把Ratio和Knee size通过Automation Modulation与Pre-Comp连到了一起，这样你的Pre-Comp时间越长GR越圆滑，反而如果Pre-Comp很短的话GR也会更猛一点。用这个预设你只需要调制Threshold和Pre-Comp，然后把RMS调到Pre-Comp的两倍左右就可以坐等奇迹了！使用方法：把zip文件解压缩至资源文件目录的FXChain下面，然后在你的FX列表内FX菜单里选择Add FXChain，之后双击加载这个预设文件就好了。
Pro Tools和Mac的用户有没有心动？其实你们也可以用任何可调制Pre-Comp/Lookahead与RMS值的压缩插件来达到这个效果，例如Klanghelm的DC8C。只可惜它的RMS最高限制是100 ms，更何况ReaComp是免费的呢。</description></item><item><title>录音输入音量标准</title><link>https://RCJacH.github.io/cn/blog/recording-volume-calibration/</link><pubDate>Sun, 07 Feb 2016 00:00:00 +0000</pubDate><guid>https://RCJacH.github.io/cn/blog/recording-volume-calibration/</guid><description>这篇文章是录音输入音量标准的解说。
我发现国内的录音爱好者和一些职业录音师，对于输入音量并没有一个绝对标准（除了用耳朵听这种无法衡量的行为），这导致同一个录音工程的同一轨会有不同音量标准的文件，甚至输入太热导致爆音。由于语言与文化的差别，我决定不逐字翻译，仅把结论和简单的理由列了出来。
关于录音输入音量所需注意的事项：
用24位或更高的音频录音。 正式录音前，试录整个演奏中音量最大的部分，并观察你的输入音量。
用你链接麦克风之后的第一个音量/增益控制钮调整输入音量，以保证你的硬件本身不会爆音。它通常在你的麦克风前级上（别名话放）。让平均音量处于-18dB左右，偶尔峰值达到-10dB左右。
如果你拥有高端的话放并想要利用其饱和度(Saturation)为录音染色，在上一个步骤的状态下慢慢提升你的输入音量达到渴望的染色，再把设备输出音量往回调到平均值-18dB左右。
不要动DAW里录音轨的音量推子！这样你才能清晰地看到你的输入音量是多少。
如果你觉得输入音量太小听不到，拉低工程内其他音轨的音量，并把你的监听音量开大。不要因为听不到录音的音轨而提升录音轨音量！
重要的事情说三遍，不要动DAW里录音轨的音量推子！
原因：
24位音频的动态范围是144dB，而16位音频的动态范围是96dB。计算方法为6乘以比特位数。
大多数硬件信噪比在70dB-80dB之间，再加上30dB-50dB的乐器动态范围，就超出了96dB能精准记载的程度，降低了信噪比，导致噪音音量的提升。
后期各阶段的压缩会继续降低信噪比。
为了不让音量峰值部分爆音，我们还需要为预留一些额外的空间，称为动态余量。
在后期处理中，使用软硬件效果器之前，我们依然需要把音频输入音量调到一个标准范围（通常效果器对不同动态会有不同的失真与压缩处理）。
24位音频的144dB的动态范围能够精确地记载录音信号，同时也能预留出动态余量，所以请好好利用其优势！</description></item><item><title>REAPER简介</title><link>https://RCJacH.github.io/cn/blog/introduction/</link><pubDate>Tue, 02 Feb 2016 00:00:00 +0000</pubDate><guid>https://RCJacH.github.io/cn/blog/introduction/</guid><description>从今天开始，本博客将在吉他/乐器练习与乐理的基础上开启新的Reaper内容分类，这个分类将主要包含REAPER (Rapid Environment for Audio Production, Engineering, and Recording) 这款DAW的进阶使用理念、音乐制作的思路与操作、音频录音与后期处理等内容。
国内用Reaper的不是很多，大部分还是处于FL Studio, PT, Cubase, Sonar, Logic, 和Live这几种更商业的DAW。当然Reaper在国外也不是很嚣张，因为人家压根没有花一分钱在宣传上，靠的都是口碑。什么是宣传？当你看到国外大师级别的录音/混音/母带工程师微笑地讲解着某个DAW功能的高清视频…嗯，那就是宣（Dai）传（Yan）。大部分音频工作者真正工作的时候都是因为某些功能不顺手、不稳定或者满足不了需求而心里默默跑过了一万只羊陀。
所以Reaper诞生了。目前有一些大牌的游戏与影视音效、音乐设计师公开表达他们对Reaper的爱：
David Farmer (霍比特人、蚁人、暗黑3、魔兽世界等)
Ariel Gross (质量效应、星球大战游戏等)
Eduardo Vaisman (分裂细胞6：黑名单、孤岛惊魂4等)
Ryan Canestro (影视作品列表)
除了音频处理功能上有实力与其他DAW竞争，Reaper包含了一下几个其他DAW只能仰望的特征：
价格 Reaper支持60天无限制的免费试用，并且用户可以在试用期之后继续使用，而限制只有打开界面时5秒钟的购买提示。如需购买正版，Reaper针对年营业额低于两万美金的商业个体或团体，以各种教育机构有一个60刀的折扣版，比不少插件都要便宜很多。同时，每一个正版的授权可以免费享用两个大版本的升级。如果你是版本5点几发布时购买的授权，你可以免费升级到6.99。按照Cockos他们家一年半一个大版本升级的进度来算，代表着3年左右的免费升级。相比之下Cubase8升到8.5还得花钱的是不是弱爆了?
更新速度 Reaper平均每两天放出一次微型的beta版本更新，修正一些Bug、添加一些API、增加一些新功能之类的。每次更新之后团队会在论坛里获得一些反馈，通常出现任何问题可能当天就修复了（每年元旦第二天就开始持续更新了）。
当然啦，普通用户可能不需要保持最新版本，而且beta版通常是为开发人员准备的。这种互联网形式的更新与反馈速度倒是值得学习一下。
自定义界面、菜单、宏 这点是Cockos公司创始人Justin Frankel (之前是Winamp的开发者) 一直强调的。先不说自定义快捷键这种行业标准，Reaper里差不多所有的界面与菜单都可以自定义。很多人首次打开Reaper觉得界面不美，但其实我们可以使用官网上用户自制的皮肤。
比如这个： 这个： 这个： 或者适合双屏的这个： 也有很多模仿款的： PT Logic皮肤与付费版 Sonar皮肤 Adobe Audition 2017皮肤 菜单方面，很多人刚开始使用的时候会觉得很乱没有逻辑。我之前也这么觉得，所以在这里推荐一下我目前正在使用的菜单系统，ReaMenus（貌似需要SWS扩展）。
使用方法： 把ReaMenus下载文件放到Reaper的资源文件目录中的MenuSets文件夹内，在Option菜单里的Customize menus/toolbars选项内，下方有一个Import。点击后选择新下载的文件，你就能看到整个菜单都变了样子呢！可惜目前菜单不支持K酱的中文翻译版，以后说不定。
而宏又是什么呢？在Reaper里，一个宏是一群操作的组合。通过宏，我们可以用一个快捷键执行多个操作。例如我们可以按一个键Solo所有名字里带有DR的轨道（鼓组），或者一键把选中的item通过原轨道效果导出成音频段放在新的一轨中（保留音量、相位包络和发送设置），也可以结合多个自制脚本达到意想不到的效果。
自制脚本 目前Reaper支持Lua、EEL、C++、Python、以及自家的Jesusonic Effects（JSFX）五种脚本语言，其中JSFX与EEL偏向实时音频或者MIDI处理。通过这些脚本，我们可以做到很多DAW本身做不到的功能 &amp;ndash; 从简单的信号处理，到改变工程制作方式（例如仿Ableton Live的Playtime），甚至自动生成MIDI也可以哟！你可能会问：“我不是程序猿怎么办？”没关系，Reaper已经自带上百个JS效果，并且官方论坛上也有很多用户自制的免费脚本。如果你能想到什么奇特的功能，不妨在论坛上留个言，也许会有大神给你写出来一个也说不定哦。
RCJacH的ReaPack Repository包含REAPER Daw使用的Lua和JS脚本与效果器
多采样率 在使用其他DAW的时候，当你拖进来任何与工程文件不同采样率的音频或者mp3时，宿主都会自动转换成一个与工程采样率一致的wav音频文件。这样不仅增加了硬盘负担，也降低了工作效率（转码也需要时间呐！）。尤其是对于声音设计师、影视音效师这种经常会用到不同来源的采样的音频工作者来说，能够把各种采样率以及各种格式的音频自由地拼在一个工程内是多么舒适的一件事情。
轻量级 + Portable Reaper的安装文件只有10-20mb，安装之后也才60mb左右。你没看错，Megabytes不是Gigabytes!</description></item></channel></rss>