<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>音乐制作 on RCJacH</title><link>https://RCJacH.github.io/cn/categories/%E9%9F%B3%E4%B9%90%E5%88%B6%E4%BD%9C/</link><description>Recent content in 音乐制作 on RCJacH</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 06 Jul 2021 20:12:58 +0800</lastBuildDate><atom:link href="https://RCJacH.github.io/cn/categories/%E9%9F%B3%E4%B9%90%E5%88%B6%E4%BD%9C/index.xml" rel="self" type="application/rss+xml"/><item><title>Airwindows Console插件系列概念及使用简介</title><link>https://RCJacH.github.io/cn/blog/aw-console-basics/</link><pubDate>Tue, 06 Jul 2021 20:12:58 +0800</pubDate><guid>https://RCJacH.github.io/cn/blog/aw-console-basics/</guid><description>我在上一篇文章中对比了一下Airwindows的Console插件， 今天我要讲讲怎样使用它们。
在此之前，请允许我先唠叨一下该系列插件的原理。
Airwindows Console插件的原理 Airwindows Console系列插件追求的是模拟(emulate)模拟(analog)调音台的相加效果。
相加效果，summing，指的是把多个信号合并在一起的过程。 对于数字信号而言，summing就是简单的加法。 举个例子， 数值为1的采样A与数值为2的采样B相加之后， 总和为3。
数学是不是很奇妙？
模拟调音台就不一样了。 它们是电力驱动的。 每个电子元件都需要用电来描绘信号、传递信号。 非常美好。 不过会出现以下这个现象。 当多个信号出现相位抵消的时候， 由于每个通道依然需要使用能量 (虽然相位抵消把这个能量“浪费”掉了)， 导致相关的电子元件变得更不稳定、更易失真， 会让信号受到一些不可描述的影响。
Console插件模仿的正是这个现象。
那它们是怎么实现的呢？
稍微有些复杂， 因为每个版本和变异所用的算法都稍微有些不同。 幸运的是， Airwindows的作者Chris写了一个剥离了染色功能只保留了核心概念的简化版。
PurestConsole。 也正是我上篇提到的日常款。
其算法很简单。 每个音轨过一个正弦函数sin(x)添加正失真， 经过DAW自带的（数字）summing功能合并之后， 再过一个反正弦函数arcsin(x)来逆转之前的失真。 Chris称之为反失真。
如果你觉得&amp;quot;Talk is cheap, show me the code&amp;quot;：
asin(sin(A) + sin(B)...) 如果你对视觉更敏感的话， 点击这里查看我在Desmos上做的图。
图中：
X轴为时域 Y轴为振幅 黑线为原信号 红线为Console渲染后的输出 蓝线为其中的差值－干湿之间的区别 目不转睛看一会儿（手动调一调参数）能注意到以下两点：
信号增强比例和输入音量成正比。 当输入总和高于0dB (y &amp;gt; 1)时， 输出值则属于未定义域。 实际使用时估计会有难听的失真， 所以do your gain-staging。 概念简要解释结束， 接下来让我们聊聊实际制作中的设置和应用吧</description></item><item><title>如何挑选Airwindows Console插件系列</title><link>https://RCJacH.github.io/cn/blog/aw-console-comparison/</link><pubDate>Thu, 01 Jul 2021 16:48:52 +0800</pubDate><guid>https://RCJacH.github.io/cn/blog/aw-console-comparison/</guid><description>Airwindows的仿调音台Summing功能的Console插件系列是好东西， 一些人甚至觉得比某款知名的A级模拟调音台还要好听。 自从开发者Chris Johnson把他家插件免费化了之后， 我每个工程都会大量使用。
最近我终于想明白了如何在REAPER内搭建Console系统 （之后有空再翻译）， 所以在想办法把Console插件直接嵌入到各种模板里。
不过他家插件有个小小的问题……选择太多了。
目前为止， 他已经出了两百多个免费插件了， 光Console相关的插件就已经有12个。 而且他每周都在开发新算法， 我作为用户反而有点跟不上他的开发速度。
对于收藏家来说， 能收集那么多奇特的染色插件来丰富我们的调色板是件非常幸福的事情。 更何况其中很多插件就像扭蛋一样， 使用之前根本不知道是干什么用的， 每次都有种拆礼物的感觉。 但是对于音频工作者来说， 这点反而是个灾难。 因为在制作过程中我们不希望被选择恐惧症打断思路， 也没有多少时间尝鲜。 实际上， 有效的工作流程应该是有一个常用插件外加两三个功能明确的代替品。 为了实现流畅的操作我们必须得使用空闲时间对这些资源进行整理， 挑出适合的， 舍弃用不上的。 为此，我创建了一个专门对比所有Airwindows Console插件的REAPER工程， 来看看每种Console到底染了什么色， 有什么区别， 哪个是最优选。
俗话说是驴是马拉出来遛遛。
工程放到REAPER官网上了，点击这里进入下载页面。
使用方式：
播放工程。 把单个静音的轨道Solo来听正弦波过Console Channel + Bus的声音。 静音的轨道名是所用的Console插件名称。 有一个没有挂插件的None轨道， 可以当成参考用的干信号， 也可以用来反向抵消其他轨来听失真染色的声音。 总线挂了几个自带的测量插件， 应该能对理解每个染色具体什么样能有些帮助， 尤其是频谱。 三个Source音轨挂了都挂上了自带的ReaSynths音源， 其中source 1在播放440Hz， source 2为880Hz（第一个泛音）， source 3则是用来测试非泛音的频率。 经过对比，我观察到了以下几点：
大部分插件哪怕仅有单轨输入也会产生失真， 除了Atmosphere, Console5RAW, Console6以及那两个PurestConsole。 多轨Summing肯定会有失真。毕竟染色就是失真，不给染色我们用这个插件干嘛。 所有失真都会产生直流偏差（0Hz信号）， 所以在ConsoleBus之后需要添加一个直流滤波器。 此方面自带的ReaEQ是所有插件中CPU用量最少的， 用它加一个20Hz的高通可以过滤大部分的偏差。 如果你想把其全部切除， Airwindows的Infrasonic插件能完美实现， 代价是更高的CPU用量。 染色是非线性的。 更高的输入音量会使过载算法产生更多泛音， 并且整个信号会在接近0dB的地方被削波， 所以别忘了Gain-Staging。 仅用正弦波的话，最难听的失真来自于Console4、Console6、及uLaw。 根据我个人的判断，最好听的几款如下： Atmosphere。据说是为了模拟声音在空气中融合的听感。 其失真较平均，没有突兀的听感。 Console5。更饱满，全频段失真上至奈奎斯特； Console5Dark， 此变异与原版反向后差别在-80dB左右， 而且主要是原频率以及前几个泛音， 但用Span把两个信号叠起来又看不出来什么区别。 此款CPU用量更少； Console5Raw，一个更干净的版本， 不过据说会出现一些不稳定的直流偏差。 Console7。听起来更空洞，基音音量会稍微小一点。 它还有个失真稍微更大一点的兄弟叫Console7Cascade。 PDConsole，PD代表Purest Drive。此款听起来失真量最小。 PurestConsole初版。 经不严谨测试它能跟PurestConsole2完全抵消， 但这款的CPU用量是所有Console里面最少的，都不到二代的一半。 而且！！这款跟Atmosphere也能完全抵消！！ 总结一下， 日常用PurestConsole， Console7当成超级模拟染色的Summing盒（它CPU用量最高）， PDConsole来当软胶（胶指粘合多个轨道的功能）， Console5或者Console5Dark当纽约式指脸怼人的硬胶。</description></item><item><title>音源模板及常见问题</title><link>https://RCJacH.github.io/cn/blog/working-with-sample-library-templates/</link><pubDate>Wed, 09 Jun 2021 07:20:52 +0800</pubDate><guid>https://RCJacH.github.io/cn/blog/working-with-sample-library-templates/</guid><description>我在2019年的时候提出过并尝试过用REAPER来搭建音源服务器的概念， 后来断断续续有人询问搭建方式，所以打算记录下来供大家参考。
但这篇文章不是关于搭建的。
这篇讲的是音源服务器到底是什么， 并且讨论一下它跟其他模板比起来有什么优势和劣势。
为了理解该服务器的价值，我们需要了解一下媒体音乐制作人在工作中会遇到的几个问题。
使用音源时会遇到的问题 音源本身的问题 当代音源有个很大的问题－他们都很大。 众多的乐器组、完善的技法和丰富的麦克风摆位的代价就是庞大的体积、无数个控制器参数、耗时间的设置。
作为作曲类工作者，我们很幸运能有数十上百种不同的乐器为我们服务。 每个乐器还能通过音高、力度、奏法等方式来调整所发出的音色。 如果我们把几千种重奏组合及上万种伴奏织体加入到这个公式内， 光管弦乐团内的乐器就可以搭配出数不胜数的声音， 更别提那些让人着迷的民族及稀有乐器。
虽然小编制音乐近些年在媒体配乐中有复苏的迹象， 但甲方通常还是期待媒体音乐制作人有为大编制创作制作的能力。
没办法，大编制听起来就是爽，但随之而来的是更多的工作量。
除非你是John Williams或者Howard Shore级别， 大编制同期实录后还能赚一笔， 否则你还是得窝电脑面前老老实实地给虚拟乐器画包络去。
问题是虚拟乐器，俗称音源，用起来很不友好。
首先它们很贵－呃，我们都是良民，肯定是要买正版的啊，eventually。 其次每款音源的麦克风配置、输出音量及部分MIDI控制器的设置可能都不一样。 再次，为了模拟实录听感或者追求大气厚重的声音， 我们经常需要结合不同的音源来取长补短。 综合下来，统一设置很费时费力。
当然，你可以反驳说音源不需要再次设置，安装完直接用即可。 我之前也是这么想的，在浪费掉几百个小时后发现这方式不可取。 主要原因是，虽然开盖即用可以马上输出音乐内容， 但当你开始要求一些细节的时候就需要反复翻说明书查控制器设置、 校准输出音量、 尝试音源搭配、 平衡不同音源的麦克风音色差、 甚至需要模拟麦克风拾音及房间声。 这些额外但又必要的劳动会让音乐制作职业难乎为继。
有什么解决办法么？
有。花点时间做一个模板来减少实际工作中的干扰。
其实为虚拟乐团搭建一个大型模板已经成为业内的常规操作了。 这个模板会包含可能使用到的所有音源所有技法， 系统的命名方案， 用颜色区分的乐器组， 预配置的效果器和轨道路由， 以及各种意想不到的预设功能。
举个REAPER适用的例子：
storyteller的REAPER管弦超级大模板
实际工作流程中要么直接把这个模板保存为新工程， 然后把当前不用的轨道静音隐藏掉， 要么从模板中把需要的轨道拷到主工程内。
这种操作我称之为单一模板法。 它在二十年前就已成为业界标准操作了。 至今仍被许多活跃的媒体作曲家（例如Blakus和Mike Verta）所使用。 有些人甚至为他们的模板打造了硬件控制系统，咳汉斯季莫咳。
无论如何，单一模板法的确可以节省大量的初始配置时间， 但使用过程中反而会引入一些其他问题。
单一模板法的问题 单一模板法最大的问题还是他们很大，只不过这次指的是文件体积。
如果你是个REAPER用户， 你应该知道REAPER包含自动备份工程文件的功能。 鉴于丢失进度是准时交工最大的阻碍， 我把备份间隔设置为每5分钟保存一次。 这么基础的功能其他DAW估计也有。
那么问题来了，如果我们将所有东西都加载进一个工程内， BASE64字符串格式的插件设置会把工程文件撑到肥胖， 动不动就上百兆。 如果我们继续自动备份的话， 每小时产生的备份文件就需要一千多兆， 到最终工作完成时可能会上到几百个G。</description></item><item><title>REAPER信号流</title><link>https://RCJacH.github.io/cn/blog/signal-flow/</link><pubDate>Fri, 23 Jun 2017 00:00:00 +0000</pubDate><guid>https://RCJacH.github.io/cn/blog/signal-flow/</guid><description>什么是信号流？
在数字音频制作领域，信号流指的是信号（例如音频或MIDI）是如何经过DAW中每一层运算的。
因为我们在实际使用中常常会需要建立路由，无论是简单的信号发送、搭建模块合成器、还是建立使用Parameter Modulation的多轨模板，清晰地了解信号在DAW中的路径以及运算顺序会有非常大的帮助。
所以我画了以下这张图。
排除模拟输入(Input)以及输出(Output)，Reaper总共有四个信号处理阶段：Take（层），Item（块），Track（轨），Master**（总线）**。每一个阶段在音频运算方面是完全一样的（单纯的加法），唯一的区别只是使用方式以而已。
以下则是一张包含包络的细节图。
注释：
Take Trim = 层音量衰减（主页面块儿上&amp;quot;边&amp;quot;往下拽的衰减）。
另外几点
我们知道REAPER只有一种万能轨道。
信号发送到另一轨的思路与块的信号输入至所包含轨性质是一样的。
母轨道(Folder Track)就像微型总线一样，把所有子轨道的信号加在一块儿再处理。
音频/MIDI通道是同路由上平行的信号流。
音频只会相加同通道的信号。
音量推子、Trim包络、音量包络三者可以同时使用，也就是说可以同时有三层音量调整的方法（平衡、段落、微调之类的）。
监听FX（Monitor FX）在音频渲染时是旁通的。</description></item><item><title>REAPER网格</title><link>https://RCJacH.github.io/cn/blog/grid-system/</link><pubDate>Sun, 06 Nov 2016 00:00:00 +0000</pubDate><guid>https://RCJacH.github.io/cn/blog/grid-system/</guid><description>当我们在创作任何非散拍音乐的时候，通常需要让音符或音频在某些程度上对齐节拍的细分（subdivision）来保证节奏的稳定性。这个时候，在DAW里，我们所用到的是节拍网格（Grid）。
它长这个样子
或者这个样子
我们通常会把网格设置成常用的音符长度，例如八分音符、十六分音符等二的倍数(2 * 2^n)，或者三连音的倍数(3 * 2^n)。可是当我们需要稍微不常见的(例如五连音、七连音、九连音)或者不规则的细分时，这些选项就不太够用了。
作为REAPER用户，我们在这块儿还是比较幸运啦，因为REAPER网格不是固定的选项而是直接提取用户输入。这样我们则不需要局限于传统固定的格子，反而可以尝试一些不寻常的搭配。
首先，REAPER的格子设置可以分别在这两个地方找到。
MIDI界面的底端
以及主界面的吸附/格子设置（Snap/Grid Settings）
我们可以在这个设置中直接输入所需的分数来设置网格的规模。
算法则是：网格大小 = 全音符 / 分母 * 分子
注：全音符是四个四分音符，所以如果用非4/4的节奏谱号可能会比较难理解。
注2：每个小节重新开始计算。
通过简单的计算我们就可以得出
全音符九连音 = 1/9
四分音符七连音 = 1/(7*4)=1/28
或者试一试不规律的组合，例如
5/27
此外，利用这种设置可以开启比较不寻常的节奏分解，例如把三拍分成五个音
3/20
我用不同组合的五连音做了个短Demo。</description></item><item><title>REAPER工具栏系统</title><link>https://RCJacH.github.io/cn/blog/toolbar-system/</link><pubDate>Thu, 22 Sep 2016 00:00:00 +0000</pubDate><guid>https://RCJacH.github.io/cn/blog/toolbar-system/</guid><description>我最近发现了一个很有意思并且非常有效的使用Reaper自定义工具栏的方法。
在其他DAW里，工具栏通常是固定不变的，我们最多只能移动或者隐藏它们。
但是在Reaper里，因为我们很幸运地拥有不少可自定义的工具栏，并且能在工具栏内添加任何操作，可能过不了多久我们的屏幕就变成这样了：
可能有些人会觉得这样排列工具栏在做大项目里是必要的，不过要在这么多图标里找到需要的操作还是要花一些时间的。
我们不如在单块面板上使用多个工具栏，然后把他们都连成一整个工具栏系统！
我现在的界面是这样的：
作为参考，以下是我对工具栏系统的组成思路。
我现在在主界面以及钢琴卷界面设置了两个层次的工具栏。
最上层的工具栏所包含的操作拥有两个目的。一是触发工程范围的事件，比如说重设MIDI设备、打开各种窗口（sws自动配色 或 heda的Note Reader）。二是作为状态栏，显示一些用快捷键触发的开关性的动作，如节拍器、预卷、吸附网格、包络跟随块等。
旁边的工具栏包含日常常用的操作，分为五类：
音轨 块 音频 包络 插件 用来切换的命令是这个：
同样功能的包含工具栏2至工具栏16，以及相关的MIDI工具栏。
这样，我们可以在母工具栏里设置一系列切换到子工具栏的操作，并在所有的子工具栏里加上一个回到母工具栏的操作。
我的钢琴卷工具栏也是用同样的方法设置的，只不过状态栏和操作栏全部放到了同一个横向面板中。
状态 选择 音符 CC 呵呵，我讨厌CC
和弦 （为了迅速输入和弦并且修改声部排列）
当然，以上的截图并非是这个系统的最终状态。我会慢慢更新并完善它：添加一些常用的操作，并删除一些不常用的。不过，这个系统理念能够更有效的利用、整理、分类Reaper的工具栏，节省我们屏幕中宝贵的显示空间。</description></item><item><title>如何寻找Reaper资源文件目录</title><link>https://RCJacH.github.io/cn/blog/resource-folder/</link><pubDate>Mon, 20 Jun 2016 00:00:00 +0000</pubDate><guid>https://RCJacH.github.io/cn/blog/resource-folder/</guid><description>在使用REAPER的过程中，无论是在添加主题、脚本、插件、还是轨道/工程模板的时候，都需要把相应的文件放到一个叫做资源文件目录的文件夹中。那么这个文件夹到底在哪儿呢？以下提供几个能找到它的方法。
最直接的方式：我们打开Reaper之后，在其默认菜单里的Option（选项）中，倒数第五个命令是Show REAPER resource path in explorer/finder&amp;hellip;（在Explorer/Finder中打开REAPER资源文件目录…），点击之后就会在系统默认的文件浏览器中打开该目录了。
以上介绍的方式通常能解决大部分寻找资源文件目录的需求， 可实际上我们可能会遇到特殊的情况，需要通过手动的方式去寻找这个资源文件目录。方法如下。
在windows系统下，不同的系统版本中的地址稍有不同，分别是：
Win XP与之前的系统：
C:\Documents andSettings(username)\Application Data\REAPER\
Win 7与之后的系统：
C:\USERS&amp;lt;username&amp;gt;\AppData\Roaming\REAPER\
以上地址，把带括号替换成你的电脑用户名，直接粘贴至文件浏览器的地址栏里，点击前往或按Enter键就到达了。更便捷的链接是这个：
%appdata%\REAPER
同样直接粘贴至文件浏览器的地址栏里就可以了。
Mac OS 系统下，该地址为：
/Users/ /Library/Application Support/REAPER
同样，把替换成你的电脑用户名即可。
此外，REAPER对于资源文件目录的优先值为：先搜索主程序所在的文件夹，如果没有资源文件，再搜索系统默认的资源文件地址（之前所介绍的）。所以如果找不到相关的资源，不放也查看一下Reaper运行文件所在的地址吧。</description></item><item><title>模拟信号与电子信号的音量关系：-20 dBFS = 0 VU</title><link>https://RCJacH.github.io/cn/blog/between-analog-and-digital-volume/</link><pubDate>Fri, 01 Apr 2016 00:00:00 +0000</pubDate><guid>https://RCJacH.github.io/cn/blog/between-analog-and-digital-volume/</guid><description>这篇文章会用最短的方式解释一下模拟信号与电子信号的音量关系。
图中有以下几点需要注意：
电子信号会在0 dBFS的状态下遭遇电子削波，而模拟信号会在+24 dBu（也就是+20VU）的状态下遭遇削波。
模拟设备在0VU以上会有逐渐增强的过载失真。
因为大部分模拟设备不会显示20dB的动态余量，而电子设备会，所以我们在用DAW的时候需要自行留出20dB的动态余量。也就是说让每一轨、每一个插件的输出音量平均值保持在-20dBFS左右（之后细讲），这样能保证我们用电子调音台时能与模拟调音台预留同样的动态余量。
在此基础上，我们可以使用各种防模拟失真的插件来模仿模拟设备的声音，例如AirWindows的Console4、ToneBooster的Ferox/Reelbus、Klanghelm的IVGI等等。</description></item><item><title>ReaComp到底有多强大？Pro Tools用户哭了。</title><link>https://RCJacH.github.io/cn/blog/reacomp-the-great/</link><pubDate>Thu, 10 Mar 2016 00:00:00 +0000</pubDate><guid>https://RCJacH.github.io/cn/blog/reacomp-the-great/</guid><description>在音频处理方面，压缩一词经常被捧上天。尤其是对听感的音量变化还不是很敏感的那些初学者们，会觉得压缩处理好像是一个非常神秘的步骤。其实压缩器的性质与手动调音量一样- 衰减音量大的部分并提升音量小的部分 – 只不过压缩比手动画音量能在更短的时间内做出反应与相对措施。那么他对音频具体有什么影响呢？我们来通过Reaper自带的ReaComp来观察一下。
ReaComp的界面的确不是最华丽的，但麻雀虽小五脏俱全：
音频信号压缩的原理是把输入信号分成两份，一份通过压缩本身的信号处理，而另一份则被用于检测衡量信号。这两份信号都可以在ReaComp内进行一定程度的处理来达到所需的效果。我们用图来解释一下ReaComp内的参数分别是什么。
假设我们输入的音频是这个样子，中间有一段音量突出的片段。
如果我们想用压缩来控制这个片段的话，我们需要调四个参数。最重要的两个是ReaComp左侧的阈值 (Threshold)以及正中央的压缩比例 (Ratio)。当输入音频音量高于阈值时，会按着所设置的Ratio对高出的范围进行衰减 (GR = Gain Reduction)。例，当输入音量比阈值高出4dB而Ratio为4:1时，超出阈值的片段会衰减至所超出范围的四分之一，输出音量则会比阈值高出1dB。
剩下的Attack和Release两个参数是用来控制衰减行为的时间b。Attack参数决定了音频从高于阈值那一刻起到最高衰减所需要的时间，而Release决定了在音频低于阈值后衰减恢复到0dB的时间。我们看一下这张图可能会更容易理解，图中的压缩比例为无限:1，也就是说GR会把超出音量降至阈值。
Class Attack选项会改变Attack的曲线，让音头衰减更慢一点，如图:
Auto Release选项是根据GR程度来计算是否需要延长Release的时间。假设我们在压缩军鼓时选择了Auto Release。如果GR是3dB，那么ReaComp会采取Release设置的x微秒；如果GR达到了20dB，Auto Release选项会让Release时间超出x，让Release时间变长。可惜的是，这样的设置在听觉上不是很舒服。许多模拟压缩所采取的Auto Release是根据GR时间长度来决定Release时间，也就是说在军鼓上衰减5dB与在贝斯上衰减5dB所造成的Release时长是不一样的。期待ReaComp能在未来的哪天实现这个功能。
在Ratio下方有一个Knee Size参数，他决定了GR与Threshold的关系。什么意思呢？想象一下，我们录过的主人声。有一些句子唱的很轻，一些句子音量稍微高一点，而副歌的时候音量会非常大。这个时候使用同一个阈值与压缩比例显然不是很合适。为什么呢？因为如果我们把阈值设置成仅仅低于副歌部分，那么前面的句子就不会被影响；而如果我们需要压缩所有信号，可能Ratio不会让副歌的音量衰减到平均范围，或者会让主歌部分压缩太多。这个时候，我们可以通过Knee Size来让GR变得更圆滑，让信号在Threshold前后Knee/2的范围内都有着不同比例的压缩。如图。
无压缩
Hard Knee
Soft Knee
Knee Size 之下的Detector input决定了检测信号的识别方式。可选项为双声道、单声道左/右、侧链双声道以及单声道（通过Channel 3 - 4的信号来激发对Channel 1 - 2的压缩）、以及Feedback (通过输出信号来激发压缩，让压缩稍微更圆润一点)。我们可以根据压缩的不同目的来选择不同识别方式，具体会在今后的文章中介绍。
再往下的两个参数分别是低通（Low Pass）与高通 (High Pass)，这个是用来调节检测信号的频段。假设我们的输入音频是一个低频比较重的木吉他，而他的低频与高频动态不是很平均的话，当低频超过了阈值，它就会触发我们不想要的衰减。这个时候如果我们把High Pass调到高于这个低频的频段，就可以让压缩只根据高频的动态来对整个信号进行适应的衰减。另一种用法是把两个参数调成齿音的频段，可以当成一个De-Esser用了。
好吧，我承认以上的参数一般压缩插件也都有（虽然调制范围有不同），并不会让ReaComp显得多么独特。但不用怕，接下来的两个参数正是ReaComp的杀手锏，那就是RMS Size和Pre-Comp。
RMS是什么？RMS，Root Mean-Square，简单来说就是一段时间的平均值。当RMS为0的时候，检测的动态为瞬间峰值的音量，也就是很多其他压缩插件的Peak Mode。如果我们把RMS调成10ms，算法会以10ms为单位检测这段时间的平均值来判断是否需要压缩，这样我们能让衰减更圆滑一点。ReaComp的RMS最高可以调到1000ms，也就是一秒。如果能调到5分钟的话差不多能直接自动做母带压缩了呵呵。
Pre-Comp算法相对更复杂一点，但我们目前可以把他看成信号检测预留时间。例如，当我们有一个特别短的音头需要压缩掉的时候，把Attack调成0（这是模拟压缩做不到的一点）则会造成一定程度的失真（因为音频采样需要从某个点瞬间移动到另一个点）。针对这个现象，我们可以调Pre-Comp，让插件在处理音头之前就已经开始进行衰减了，这样当我们处理到音头的时候就不会造成突然地失真。效果如下图：
注意，因为使用Pre-Comp需要让插件提前识别之后的音频，会增加宿主的延迟，所以可能这个工具更适合后期混音而非现场演奏、录音。
好了，我们把ReaComp中大部分参数意义复习了一遍，也该讲一讲它的神奇之处了。这个技巧最先由Cockos论坛会员ashcat_lt提出，准备好颠覆我们对压缩的概念吧。
我们知道RMS是截取一个段落的平均值，我们又知道Pre-Comp能让插件“预知”一段时间的音量。那么如果我们把Pre-Comp设置成RMS的一半左右，我们处理的则是一个峰值与它前后一段时间的平均值。这样等于音量会自然地在峰值之前衰减，而在峰值之后恢复。同时，因为Attack和Release已经包含在整个程序内了，我们不需要额外地添加Attack和Release。峰值的音头形状可能稍微取决于RMS与Pre-Comp * 2之差。利用这个方法，我们可以把Knee Size和Threshold调到比平常高一点的位置，让输入音频一直保持Knee中间的状态，GR大概保持在1.5dB以下就好了。这个压缩技术的效果就是在保留音头的情况下非常自然地降低了动态范围，甚至根本听不出来压缩的痕迹!
操作起来很简单，你只需要如下图这样设置，然后根据你的输入及目的来调制红色框内的Threshold、Ratio、与Knee Size(其实都可以不动)。
我还做了一个ReaComp预设，并把Ratio和Knee size通过Automation Modulation与Pre-Comp连到了一起，这样你的Pre-Comp时间越长GR越圆滑，反而如果Pre-Comp很短的话GR也会更猛一点。用这个预设你只需要调制Threshold和Pre-Comp，然后把RMS调到Pre-Comp的两倍左右就可以坐等奇迹了！使用方法：把zip文件解压缩至资源文件目录的FXChain下面，然后在你的FX列表内FX菜单里选择Add FXChain，之后双击加载这个预设文件就好了。
Pro Tools和Mac的用户有没有心动？其实你们也可以用任何可调制Pre-Comp/Lookahead与RMS值的压缩插件来达到这个效果，例如Klanghelm的DC8C。只可惜它的RMS最高限制是100 ms，更何况ReaComp是免费的呢。</description></item><item><title>你还在画CC吗？其实Reaper这么用更强大！</title><link>https://RCJacH.github.io/cn/blog/no-more-cc/</link><pubDate>Thu, 10 Mar 2016 00:00:00 +0000</pubDate><guid>https://RCJacH.github.io/cn/blog/no-more-cc/</guid><description>许多人对Reaper自带的MIDI Control Change(MIDI CC控制器)功能很不满。可以理解，Reaper在MIDI CC这一块儿缺少了很多其他DAW特征性的功能，比如说Logic与AbletonLive的曲线功能，Cubase的Expression Map，Studio One的各种LFO形状的画笔等等。
虽然目前有一些能提高CC效率的工具，例如这款MIDI Velocity/CC Tool。
但他们治标不治本，无法大幅度提升编曲效率。尤其当我们做吉他
做弦乐
弦乐组
或任何需要画大量CC表情控制器的时候，这些工具所能给予的帮助实在是少得可怜。
再加上一个技术性的原因：Reaper工程文件是可以当成文本文件直接打开并修改的！我们可以用文本编辑器把某个插件段落的代码删掉，来挽救一个持续崩溃的工程。懂行的朋友还可以用GIT来监测工程版本，是一个很方便的功能。但我们开始画CC的时候会发现，因为每一个点都会明确记载，所以工程文件会变得无比巨大，轨道稍微多一点的工程体积会上到__几十兆甚至一百多兆__。如果你还开启了定时文件备份的功能（比如说每15分钟备份至新文件），你会在几小时之后发现硬盘空间少了好几个G！这真是一个迫使你去换新固态硬盘的好办法…
而参数包络在Reaper里反而更受到重视，不仅可以使用曲线，也有很厉害的脚本插件，比如说这款Envelope Point Generator
所以，我下了一个决定：用包络来代替CC！用包络来画曲线不仅减少了工程文件大小，也能让修改的时候变得很轻松（时间和位置只需拖拉一个点，而不需要每一个CC信息都细修）。
那么这个怎么做到的呢？有以下两种方法。
一，用ReaControlMIDI来控制CC参数。 Reaper自带的ReaControlMIDI长这个样子:
而我们需要用的是红色方框内的功能。首先先点击橙色箭头指向的Enable选项来开启这个功能，用右边的RawMode来开启传统128位的CC系统，然后用下方的菜单来选择需要控制的CC参数，最常见的估计是CC1（力度/颤音深度），弯音轮，与CC11（表情/音量）。
记得把它排列在音源前面。
这个时候我们点击轨道上的trim标签
来打开包络设置。
我们能看到ReaControlMIDI所有可以操作的参数，其中包含CC1、PW、和CC11。我们只需点击红色圈内的选框就能把包络当成CC来画啦！
二，使用音源参数 当我们把上一个小节的方法运用到音源参数的时候，会比通过ReaControlMIDI中转成CC更直接。我们可以直接控制任何音源所有可以操作的外部参数，例如这款免费合成器Helm所包含的一部分参数:
Reaper版本5.1开始支持用MIDI CC来直接控制参数，不需要经过ReaControlMIDI，如图。
注释：选择一个可控制的参数，通过选择Param -&amp;gt; MIDI Link -&amp;gt; CC -&amp;gt; 我们需要的控制器编号。图中使用的JS只是模拟CC 1的输入。
如果想利用插件（如JS脚本或序列器）在原MIDI基础上添加新信息的话，只需要右键插件输入输出选项，在MIDI output菜单里选择Merges with MIDI bus（感谢Tee先生的补充），如图：
当然，我们在编曲时使用CC最多的恐怕是Kontakt内的采样音源。我们可以通过Auto一栏的Host Automation（宿主自动化）来设置。
有一些音源，尤其是Native Instruments自家的音源，已经给你设置好了，比如说这款Granduer钢琴。
这种音源你可以马上用起来！比如在钢琴轨上通过修改”Color”、”Transient”、“Tonal Depth”三个包络，让音源在不同段落包含着不同的音色与音头强度，比后期压缩要更有针对性。
对于非NI本厂的音源来说，很遗憾，我们没有办法享受到已调制好的预设。所以需要自己动手，做一次最初的设置，然后保存为乐器模板。方法如下:
首先加载音源，例如Orange Tree Samples公司出品的Strawberry吉他，然后把Host里任何一栏拖拉到需要调制的参数上。如果这个参数是可以通过外部调制的（按钮与旋钮），鼠标箭头会变成一个带有加号的箭头，否则说明此参数不能被外部控制（下拉菜单）。
稍微花一点时间把所有参数都设置成宿主自动化吧，必要的话可以用Param菜单的Alias Parameter功能为某个包络控制起一个自己能看得懂的名字。
当我们把每一个常用参数都设置成一个宿主自动化之后，就可以随心所欲的画曲线了！像下面这一轨电吉他
记得右键轨道选择Save tracks as track template来把设置好的选项保存为轨道模板噢！
因编曲需要，我已经设置好了几个Kontakt乐器的配置，并为每个参数设置了英文名称。有兴趣的朋友可以随意下载使用。
Sample Modeling Kontakt铜管音源，包含小号x4、长号x4、圆号x4。
NI最新Symphonic Series String Ensemble弦乐音源组，同时加载小提I、小提II、中提、大提、低音提琴。</description></item><item><title>录音输入音量标准</title><link>https://RCJacH.github.io/cn/blog/recording-volume-calibration/</link><pubDate>Sun, 07 Feb 2016 00:00:00 +0000</pubDate><guid>https://RCJacH.github.io/cn/blog/recording-volume-calibration/</guid><description>这篇文章是录音输入音量标准的解说。
我发现国内的录音爱好者和一些职业录音师，对于输入音量并没有一个绝对标准（除了用耳朵听这种无法衡量的行为），这导致同一个录音工程的同一轨会有不同音量标准的文件，甚至输入太热导致爆音。由于语言与文化的差别，我决定不逐字翻译，仅把结论和简单的理由列了出来。
关于录音输入音量所需注意的事项：
用24位或更高的音频录音。 正式录音前，试录整个演奏中音量最大的部分，并观察你的输入音量。
用你链接麦克风之后的第一个音量/增益控制钮调整输入音量，以保证你的硬件本身不会爆音。它通常在你的麦克风前级上（别名话放）。让平均音量处于-18dB左右，偶尔峰值达到-10dB左右。
如果你拥有高端的话放并想要利用其饱和度(Saturation)为录音染色，在上一个步骤的状态下慢慢提升你的输入音量达到渴望的染色，再把设备输出音量往回调到平均值-18dB左右。
不要动DAW里录音轨的音量推子！这样你才能清晰地看到你的输入音量是多少。
如果你觉得输入音量太小听不到，拉低工程内其他音轨的音量，并把你的监听音量开大。不要因为听不到录音的音轨而提升录音轨音量！
重要的事情说三遍，不要动DAW里录音轨的音量推子！
原因：
24位音频的动态范围是144dB，而16位音频的动态范围是96dB。计算方法为6乘以比特位数。
大多数硬件信噪比在70dB-80dB之间，再加上30dB-50dB的乐器动态范围，就超出了96dB能精准记载的程度，降低了信噪比，导致噪音音量的提升。
后期各阶段的压缩会继续降低信噪比。
为了不让音量峰值部分爆音，我们还需要为预留一些额外的空间，称为动态余量。
在后期处理中，使用软硬件效果器之前，我们依然需要把音频输入音量调到一个标准范围（通常效果器对不同动态会有不同的失真与压缩处理）。
24位音频的144dB的动态范围能够精确地记载录音信号，同时也能预留出动态余量，所以请好好利用其优势！</description></item><item><title>REAPER简介</title><link>https://RCJacH.github.io/cn/blog/introduction/</link><pubDate>Tue, 02 Feb 2016 00:00:00 +0000</pubDate><guid>https://RCJacH.github.io/cn/blog/introduction/</guid><description>从今天开始，本博客将在吉他/乐器练习与乐理的基础上开启新的Reaper内容分类，这个分类将主要包含REAPER (Rapid Environment for Audio Production, Engineering, and Recording) 这款DAW的进阶使用理念、音乐制作的思路与操作、音频录音与后期处理等内容。
国内用Reaper的不是很多，大部分还是处于FL Studio, PT, Cubase, Sonar, Logic, 和Live这几种更商业的DAW。当然Reaper在国外也不是很嚣张，因为人家压根没有花一分钱在宣传上，靠的都是口碑。什么是宣传？当你看到国外大师级别的录音/混音/母带工程师微笑地讲解着某个DAW功能的高清视频…嗯，那就是宣（Dai）传（Yan）。大部分音频工作者真正工作的时候都是因为某些功能不顺手、不稳定或者满足不了需求而心里默默跑过了一万只羊陀。
所以Reaper诞生了。目前有一些大牌的游戏与影视音效、音乐设计师公开表达他们对Reaper的爱：
David Farmer (霍比特人、蚁人、暗黑3、魔兽世界等)
Ariel Gross (质量效应、星球大战游戏等)
Eduardo Vaisman (分裂细胞6：黑名单、孤岛惊魂4等)
Ryan Canestro (影视作品列表)
除了音频处理功能上有实力与其他DAW竞争，Reaper包含了一下几个其他DAW只能仰望的特征：
价格 Reaper支持60天无限制的免费试用，并且用户可以在试用期之后继续使用，而限制只有打开界面时5秒钟的购买提示。如需购买正版，Reaper针对年营业额低于两万美金的商业个体或团体，以各种教育机构有一个60刀的折扣版，比不少插件都要便宜很多。同时，每一个正版的授权可以免费享用两个大版本的升级。如果你是版本5点几发布时购买的授权，你可以免费升级到6.99。按照Cockos他们家一年半一个大版本升级的进度来算，代表着3年左右的免费升级。相比之下Cubase8升到8.5还得花钱的是不是弱爆了?
更新速度 Reaper平均每两天放出一次微型的beta版本更新，修正一些Bug、添加一些API、增加一些新功能之类的。每次更新之后团队会在论坛里获得一些反馈，通常出现任何问题可能当天就修复了（每年元旦第二天就开始持续更新了）。
当然啦，普通用户可能不需要保持最新版本，而且beta版通常是为开发人员准备的。这种互联网形式的更新与反馈速度倒是值得学习一下。
自定义界面、菜单、宏 这点是Cockos公司创始人Justin Frankel (之前是Winamp的开发者) 一直强调的。先不说自定义快捷键这种行业标准，Reaper里差不多所有的界面与菜单都可以自定义。很多人首次打开Reaper觉得界面不美，但其实我们可以使用官网上用户自制的皮肤。
比如这个： 这个： 这个： 或者适合双屏的这个： 也有很多模仿款的： PT Logic皮肤与付费版 Sonar皮肤 Adobe Audition 2017皮肤 菜单方面，很多人刚开始使用的时候会觉得很乱没有逻辑。我之前也这么觉得，所以在这里推荐一下我目前正在使用的菜单系统，ReaMenus（貌似需要SWS扩展）。
使用方法： 把ReaMenus下载文件放到Reaper的资源文件目录中的MenuSets文件夹内，在Option菜单里的Customize menus/toolbars选项内，下方有一个Import。点击后选择新下载的文件，你就能看到整个菜单都变了样子呢！可惜目前菜单不支持K酱的中文翻译版，以后说不定。
而宏又是什么呢？在Reaper里，一个宏是一群操作的组合。通过宏，我们可以用一个快捷键执行多个操作。例如我们可以按一个键Solo所有名字里带有DR的轨道（鼓组），或者一键把选中的item通过原轨道效果导出成音频段放在新的一轨中（保留音量、相位包络和发送设置），也可以结合多个自制脚本达到意想不到的效果。
自制脚本 目前Reaper支持Lua、EEL、C++、Python、以及自家的Jesusonic Effects（JSFX）五种脚本语言，其中JSFX与EEL偏向实时音频或者MIDI处理。通过这些脚本，我们可以做到很多DAW本身做不到的功能 &amp;ndash; 从简单的信号处理，到改变工程制作方式（例如仿Ableton Live的Playtime），甚至自动生成MIDI也可以哟！你可能会问：“我不是程序猿怎么办？”没关系，Reaper已经自带上百个JS效果，并且官方论坛上也有很多用户自制的免费脚本。如果你能想到什么奇特的功能，不妨在论坛上留个言，也许会有大神给你写出来一个也说不定哦。
RCJacH的ReaPack Repository包含REAPER Daw使用的Lua和JS脚本与效果器
多采样率 在使用其他DAW的时候，当你拖进来任何与工程文件不同采样率的音频或者mp3时，宿主都会自动转换成一个与工程采样率一致的wav音频文件。这样不仅增加了硬盘负担，也降低了工作效率（转码也需要时间呐！）。尤其是对于声音设计师、影视音效师这种经常会用到不同来源的采样的音频工作者来说，能够把各种采样率以及各种格式的音频自由地拼在一个工程内是多么舒适的一件事情。
轻量级 + Portable Reaper的安装文件只有10-20mb，安装之后也才60mb左右。你没看错，Megabytes不是Gigabytes!</description></item><item><title>英文缩写规则</title><link>https://RCJacH.github.io/cn/blog/english-abbreviation-in-naming/</link><pubDate>Sat, 05 Sep 2015 00:00:00 +0000</pubDate><guid>https://RCJacH.github.io/cn/blog/english-abbreviation-in-naming/</guid><description>在音频制作时候，经常会遇到音轨名称太长的情况，比如说PAD Sequence Glitter，或者Electric Guitar Wah Tremolo。这么长的名字一般DAW是不会显示的，所以我们需要简化这个音轨名称让DAW能正常显示所有的文字。前些日子看了一篇关于英文缩写的规则，翻出来分享一下：
英文缩写：（abbreviation，来自于拉丁语中的brevis，代表short简短）
Shortening：缩略一个词使它保留原单词的前几个字母，一般会在结尾加一个句号&amp;quot;.&amp;quot; 例：cont. = continued。 注释：如果缩略单词能形成另外一个单词，句号会被省略。例：limo = limousine。
这种缩略不一定是非正式用语，比如：bus = autobus，taxi = taxicab等等。
注释：有些时候会为了发音或拼写对缩略单词进行变化，例如：bike = bicycle。
Contraction：使用单词第一个字母与最后一个字母，并省略中间的字母。例如：Dr. doctor, St. = saint/street。需要在结尾加句号&amp;quot;.&amp;quot;。另一种缩短方式是用单引号apostrophe &amp;rsquo; 来标注省略字母，比如说：can&amp;rsquo;t = cannot，didn&amp;rsquo;t = did not等等。 注释：我个人发现另一种缩短的方法：省略元音与重复的字母，保留辅音。例如：cls. = Class， src = source，gtr = guitar。 Initialism：对于词组，可以使用每个词的首写字母。CIA/C.I.A.，US/U.S.。这种缩写方法越来越倾向不使用句号来分开字母。
Acronyms：这种缩写方法是让词组的每个词形成另外一个完整的单词，比如：AIDS，laser，或者像DAW以及Reaper。这种情况缩写反而成为了常用的词汇，而完整体通常用于解释目的。
灵活地去运用以上四个方法，我们便可很便捷地、系统地去简化音频相关英文单词。例如之前的PAD Sequence Glitter可以写成 PD sq Gltr，而后者可以标记为EG w trem。这样一眼就知道每一轨代表什么乐器了。</description></item></channel></rss>